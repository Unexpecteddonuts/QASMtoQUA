# QASMtoQUA
A python parser to parse OPENQASM 2.0 to QUA(Quantum Universal Assembly)

# TBD
1. The QASM data will be received a JSON with headers proc_id, rec_time, QASM_code, h_score, will use the `json.loads()` function from the `json` library
   - the proc_id data will be used to identify the data before and after preprocessing and then after the hardware processing.
   - the rec_time data will be used to store the the submition in a `submition log`
   - the QASM_code data will be extracted and sent through the first part of the preprocessing stage where it will be converted to QUA code
   - h_score will be used in the log to identify the computational complexity of the algorithm/circuit, `metrics for this TBD`, may use for task queing purposes

2. Define the QASM grammar: Study the QASM specification and define the grammar rules for the language. Identify the syntax rules, keywords, statements, and expressions used in QASM.

3. Implement the lexer: The lexer takes the input QASM code as a string and converts it into a stream of tokens. Each token represents a meaningful unit in the code, such as keywords, identifiers, numbers, symbols, etc. Use regular expressions or a lexer generator tool like Lex or Ply to implement the lexer.

4. Implement the parser: The parser takes the stream of tokens generated by the lexer and constructs a parse tree according to the grammar rules. Implement the parser using a parsing technique such as Recursive Descent, LL(1), or LALR(1) parsing. Tools like Yacc or Ply can help in parser generation.

5. Define the semantics: Assign meaning to the parsed constructs of QASM. Define the actions that need to be performed for each production rule in the grammar. These actions may include creating data structures, performing calculations, or generating Qua code.

6. Build the symbol table: Create a symbol table to keep track of the defined variables, registers, and gates in the QASM code. The symbol table helps in resolving names and maintaining consistency during parsing and semantic analysis.

7. Perform semantic analysis: Perform semantic checks on the parsed QASM code to ensure correctness and consistency. This includes checking for variable declarations, type compatibility, and scoping rules.

8. Generate Qua code: As part of the semantic analysis phase, generate the equivalent Qua code based on the parsed QASM constructs. Map the QASM gate operations, measurements, and other instructions to their corresponding Qua counterparts.

    
     
